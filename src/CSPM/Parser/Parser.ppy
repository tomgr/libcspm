{
module CSPM.Parser.Parser (
    parseFile_, parseInteractiveStmt_, parseExpression_
) 
where

-- To generate the corresponding .hs file run the following commands
-- cpp -P src/CSPM/Parser/Parser.ppy > src/CSPM/Parser/Parser.y
-- happy --ghc --coerce --array src/CSPM/Parser/Parser.y
-- rm src/CSPM/Parser/Parser.y

-- i.e.: cpp -P src/CSPM/Parser/Parser.ppy > src/CSPM/Parser/Parser.y && happy --ghc --coerce --array src/CSPM/Parser/Parser.y && rm src/CSPM/Parser/Parser.y

import qualified Data.ByteString.Char8 as B
import Data.Char
import Data.List (groupBy, nub, sort, sortBy, (\\))
import qualified Data.Map as M
import Data.Maybe (catMaybes)

import CSPM.Syntax.AST
import CSPM.Syntax.Literals
import CSPM.Syntax.Names
import CSPM.Syntax.Types hiding (TDot, TChar)
import CSPM.Parser.Exceptions
import CSPM.Parser.Lexer
import CSPM.Parser.Monad
import CSPM.Parser.Tokens
import Prelude hiding (getChar)
import Util.Annotated
import Util.Exception (panic)
}

-- Lift the src span from $1 to the resulting token
-- (i.e. LL (LLit ...) (Exp ...) = LExp ...
#define LL liftLoc $1
-- Make a src span from the first item to the last
#define AN annotate $1
#define AN2 annotate2 $1 $>
#define AN2L annotate2List $1 $>
#define AN2LL annotate2Lista $1 $>

%name parseFile_ CSPMFile
%name parseInteractiveStmt_ InteractiveStmt
%name parseExpression_ CExp
%lexer { getNextTokenWrapper } { L _ TEOF }
%monad { ParseMonad }
%tokentype { LToken }
%error { parseError }
%token
    integer_literal     { L _ (TInteger _) }
    char_literal        { L _ (TChar _) }
    string_literal      { L _ (TString _) }
    ident               { L _ (TIdent _) }
    newline             { L _ TNewLine }
    print_literal       { L _ (TPrint _) }

    "false"             { L _ TFalse }
    "true"              { L _ TTrue }

    "="                 { L _ TDefineEqual }

    ","                 { L _ TComma }
    "."                 { L _ TDot }
    "?"                 { L _ TQuestionMark }
    "$"                 { L _ TDollar }
    "!"                 { L _ TExclamationMark }
    ".."                { L _ TDoubleDot }
    ":"                 { L _ TColon }
    "<-"                { L _ TDrawnFrom }
    "<->"               { L _ TTie }
    "|"                 { L _ TPipe }

    "@@"                { L _ TDoubleAt }
    "_"                 { L _ TWildCard }

    "if"                { L _ TIf }
    "then"              { L _ TThen }
    "else"              { L _ TElse }
    "let"               { L _ TLet }
    "within"            { L _ TWithin }
    "\\"                { L _ TBackSlash }
    "@"                 { L _ TLambdaDot }
    "channel"           { L _ TChannel }
    "datatype"          { L _ TDataType }
    "subtype"           { L _ TSubType }
    "external"          { L _ TExternal }
    "transparent"       { L _ TTransparent }
    "nametype"          { L _ TNameType }
    "module"            { L _ TModule }
    "exports"           { L _ TExports }
    "endmodule"         { L _ TEndModule }
    "instance"          { L _ TInstance }
    "::"                { L _ TScope }
    "Timed"             { L _ TTimed }

    OfType              { L _ TOfType }
    "=>"                { L _ TYield }
    "=>*"               { L _ TYieldStar }

    "assert"            { L _ TAssert }
    "deadlock free"     { L _ TDeadlockFree }
    "livelock free"     { L _ TLivelockFree }
    "divergence free"   { L _ TDivergenceFree }
    "has trace"         { L _ THasTrace }
    "deterministic"     { L _ TDeterministic }
    "tau priority"      { L _ TTauPriority }
    "partial order reduce" { L _ TPartialOrderReduce }
    string_option_literal { L _ (TStringOption _) }
    refines             { L _ (TRefines _) }
    model               { L _ (TModel _) }
    
    "not"               { L _ TNot }
    "anot"              { L _ TAssertNot }
    "and"               { L _ TAnd }
    "or"                { L _ TOr }
    "=="                { L _ TEq }
    "!="                { L _ TNotEq }
    "<="                { L _ TLtEq }
    ">="                { L _ TGtEq }
    "<>"                { L _ TEmptySeq }
    "<"                 { L _ TLt }
    ">"                 { L _ TGt }
    "close_seq"         { L _ TCloseSeq }

    "+"                 { L _ TPlus }
    "-"                 { L _ TMinus }
    "*"                 { L _ TTimes }
    "/"                 { L _ TDivide }
    "%"                 { L _ TMod }

    "^"                 { L _ TConcat }
    "#"                 { L _ THash }

    "("                 { L _ TLParen }
    ")"                 { L _ TRParen }
    "{"                 { L _ TLBrace }
    "}"                 { L _ TRBrace }
    "(|"                { L _ TLMap }
    "|)"                { L _ TRMap }
    "{|"                { L _ TLPipeBrace }
    "|}"                { L _ TRPipeBrace }
    "[["                { L _ TLDoubleSqBracket }
    "]]"                { L _ TRDoubleSqBracket }
    "[|"                { L _ TLPipeSqBracket }
    "|]"                { L _ TRPipeSqBracket }
    "["                 { L _ TLSqBracket }
    "]"                 { L _ TRSqBracket }

    "[]"                { L _ TExtChoice }
    "|~|"               { L _ TIntChoice }
    "|||"               { L _ TInterleave }
    "->"                { L _ TPrefix }
    "/\\"               { L _ TInterrupt }
    "[>"                { L _ TSlidingChoice }
    "|>"                { L _ TRException }
    "||"                { L _ TParallel }
    "|\\"               { L _ TProject }
    ";"                 { L _ TSemiColon }
    "&"                 { L _ TGuard }

    "[+"                { L _ TLSyncExtChoice }
    "+]"                { L _ TRSyncExtChoice }
    "/+"                { L _ TLSyncInterrupt }
    "+\\"               { L _ TRSyncInterrupt }

-- TODO: lambda dot
%nonassoc "let" "within" "@" "if" "then" "else"
%nonassoc "@@" --COLON AT AS
%left "\\" "|\\"
%left "|||"
%nonassoc "|>" "[|" "|]" "[" "]" "||" --"[[" "]]" -- PROB
%left "|~|"
%left "[]" "[+" "+]"
%left "/\\" "/+" "+\\"
%left "[>"
%left ";"
%right "&" "->" --GUARD WHERESQ (this is &[)
%left "?" "!" "$"
%right "=>" "=>*"
%right "."  -- TODO: correct?
%nonassoc ":"
%left "or"
%left "and"
%left "not"
%nonassoc "==" "!=" "<" "<=" ">" ">="
%left "+" "-"
%left "*" "/" "%"
%left "#"
%left "^"
%nonassoc "(" ")" "[[" "]]"
%nonassoc "::"

%%

CSPMFile :: { PCSPMFile }
    :
    Newlines0 DeclList                          { mkLoc Unknown (CSPMFile $2) }
    
InteractiveStmt :: { PInteractiveStmt }
    :
    "let" Exp "=" CExp                          {% do
                                                    d <- convDecl $2 $4 
                                                    d <- annotateWithSymbolTable d
                                                    return $ AN2 (Bind [d])}
    | "assert" "anot" Assertion                 { AN2 (RunAssertion (AN2 (ASNot $3))) }
    | "assert" Assertion                        { AN2 (RunAssertion $2) }
    | "external" NameCommaList1                 {% do
                                                    d <- annotateWithSymbolTable $
                                                        AN2L (External (map unLoc $2))
                                                    return $ AN2L (Bind [d]) }
    | "transparent" NameCommaList1              {% do
                                                    d <- annotateWithSymbolTable $
                                                        AN2L (Transparent (map unLoc $2))
                                                    return $ AN2L (Bind [d]) }
    | CExp                                      { AN (Evaluate $1) }

Newlines :
    newline                                     { }
    | Newlines newline                          { }
Newlines0 :
                                                { }
    | Newlines0 newline                         { }

DeclList :: { [PDecl] }
    :
                                                { [] }
    | DeclList1                                 { $1 }
DeclList1 :: { [PDecl] }
    :
    rDeclList1NC                                { attachTypeAnnotations $
                                                    combineDecls (reverse $1) }
rDeclList1NC :: { [PDecl] }
    :
    Decl                                        { [$1] }
    | rDeclList1NC Newlines MaybeDecl           { case $3 of 
                                                    Just d -> d:$1
                                                    Nothing -> $1 }
MaybeDecl :: { Maybe PDecl }
    :
                                                { Nothing }
    | Decl                                      { Just $1 }

Decl :: { PDecl }
    :
    DeclA                                       {% annotateWithSymbolTable $1 }
DeclA :: { PDecl }
    :
    Exp "=" CExp                                {% convDecl $1 $3 }
    | "channel" NameCommaList1                  { AN2L (Channel (map unLoc $2) Nothing Nothing) }
    | "channel" NameCommaList1 ":" CExp         { AN2 (Channel (map unLoc $2) (Just $4) Nothing) }
    | "datatype" Name "=" DataTypeClauseList1   { AN2L (DataType (unLoc $2) $4) }
    | "subtype" Name "=" DataTypeClauseList1    { AN2L (SubType (unLoc $2) $4) }
    | "external" NameCommaList1                 { AN2L (External (map unLoc $2)) }
    | "transparent" NameCommaList1              { AN2L (Transparent (map unLoc $2)) }
    | "assert" "anot" Assertion                 { AN2 (Assert (AN2 (ASNot $3))) }
    | "assert" Assertion                        { AN2 (Assert $2) }
    | "nametype" Name "=" CExp                  { AN2 (NameType (unLoc $2) $4 Nothing) }
    | "module" Name OptPatList Newlines DeclList
      "exports" Newlines DeclList "endmodule"    { AN2 (Module (unLoc $2) $3 
                                                    (map checkModuleDecl $5)
                                                    (map checkModuleDecl $8)) }
    | "Timed" "{" DeclList "}"                  { AN2 (TimedSection Nothing
                                                    Nothing
                                                    (map checkTimedDecl $3)) }
    | "Timed" "(" CExp ")" "{" DeclList "}"     { AN2 (TimedSection Nothing
                                                    (Just $3)
                                                    (map checkTimedDecl $6)) }
    | NameCommaList1 OfType STypeScheme         { AN2LL (ParsedTypeAnnotation
                                                    (map unLoc $1) $3) }
    | "instance" Name "=" MaybeQualName ExpList { AN2L (ModuleInstance (unLoc $2)
                                                    (unLoc $4) $5 M.empty Nothing) }
    | "instance" Name "=" MaybeQualName         { AN2 (ModuleInstance (unLoc $2)
                                                    (unLoc $4) [] M.empty Nothing) }
    | print_literal                             { LL (PrintStatement
                                                    (getPrintString $1)) }

OptPatList :: { [PPat] }
    :
                                                { [] }
    | "(" rPatList ")"                          { reverse $2 }

PatList :: { [PPat] }
    :
    rPatList                                    { reverse $1 }

ExpList :: { [PExp] }
    :
    "(" CExpList ")"                            { $2 }

AnglesExpList :: { [PExp] }
    :
    BegSeq CExpList EndSeq                      { $2 }
    
Assertion :: { PAssertion }
    :
    CExp refines CExp OptModelOptionList    { AN2L (Refinement $1 (getRefinesModel $2) $3 $4) }
    | CExp SemanticProperty OptModelOptionList  { AN2L (PropertyCheck $1 (unLoc $2) Nothing $3) }
    | CExp SemanticProperty model OptModelOptionList { AN2L (PropertyCheck $1 (unLoc $2) (Just (getPropModel $3)) $4) }
    | CExp "has trace" AnglesExpList OptModelOptionList { AN2L (PropertyCheck $1 (HasTrace $3) Nothing $4) }
    | CExp "has trace" model AnglesExpList OptModelOptionList { AN2L (PropertyCheck $1 (HasTrace $4) (Just (getPropModel $3)) $5) }

SemanticProperty :: { Located (SemanticProperty UnRenamedName) }
    :
    "deadlock free"                             { LL DeadlockFreedom }
    | "livelock free"                           { LL LivelockFreedom }
    | "divergence free"                         { LL LivelockFreedom }
    | "deterministic"                           { LL Deterministic }

OptModelOptionList :: { [PModelOption] }
    :
                                                { [] }
    | rModelOptionList                          { checkModelOptions (reverse $1) }

rModelOptionList :: { [PModelOption] }
    :
    ModelOption                                 { [$1] }
    | rModelOptionList ModelOption              { $2:$1 }

ModelOption :: { PModelOption }
    :
    "tau priority" CExp                         { AN2 (TauPriority $2) }
    | "partial order reduce" string_option_literal { AN (PartialOrderReduce (Just (getStringOption $2))) }
    | "partial order reduce"                    { AN (PartialOrderReduce Nothing) }

DataTypeClause :: { PDataTypeClause }
    :
    Name "." CExp                               { AN2 (DataTypeClause (unLoc $1) (Just $3) Nothing) }
    | Name                                      { AN (DataTypeClause (unLoc $1) Nothing Nothing) }
DataTypeClauseList1 :: { [PDataTypeClause] }
    :
    rDataTypeClauseList                         { reverse $1 }
rDataTypeClauseList :: { [PDataTypeClause] }
    :
    DataTypeClause                              { [$1] }
    | rDataTypeClauseList "|" DataTypeClause    { $3:$1 }

MaybeQualName :: { Located UnRenamedName }
    : 
    ident                           { LL (UnQual (OccName (getName $1))) }
    | ident "::" MaybeQualName      { AN (Qual (OccName (getName $1)) (unLoc $3)) }

Name :: { Located UnRenamedName }
    : 
    ident                           { LL (UnQual (OccName (getName $1))) }

NameCommaList1 :: { [Located UnRenamedName] }
    :
    rNameCommaList                  { reverse $1 }
rNameCommaList :: { [Located UnRenamedName] }
    :
    Name                            { [$1] }
    | rNameCommaList "," Name       { $3:$1 }

STypeScheme :: { PSTypeScheme }
    :
    SType                                       { LL (STypeScheme [] [] $1) }
    | STypeConstraint "=>" SType                { LL (STypeScheme [] [$1] $3) }
    | "(" STypeConstraint1 ")" "=>" SType       { LL (STypeScheme [] $2 $5) }

STypeConstraint1 :: { [PSTypeConstraint] }
    :
    rSTypeConstraintList1                       { reverse $1 }
rSTypeConstraintList1 :: { [PSTypeConstraint] }
    :
    rSTypeConstraintList1 "," STypeConstraint   { $3:$1 }
    | STypeConstraint                           { [$1] }

SType :: { PSType }
    :
    MaybeQualName                   { LL (STVar (unLoc $1)) }
    | "{" SType "}"                 { AN2 (STSet $2) }
    | "<" SType ">"                 { AN2 (STSeq $2) }
    | "(" SType ")"                 { AN2 (STParen $2) }
    | MaybeQualName "=>*" SType     { AN2 (STExtendable $3 (unLoc $1)) }
    | SType "=>" SType              { AN2 (STDotable $1 $3) }
    | "(|" SType "=>" SType "|)"    { AN2 (STMap $2 $4) }
    | SType "." SType               { makeSTDot $1 $3 }
    | "(" STypeCommaList2 ")"       { AN2 (STTuple $2) }
    | "(" ")" "->" SType            { AN2 (STFunction [] $4) }
    | SType "->" SType              { AN2 (STFunction
                                        (getFuncArgs $1) $3) }

STypeConstraint :: { PSTypeConstraint }
    :
    ident Name                      { AN2 (STypeConstraint
                                        (constraintForName (getLoc $1)
                                            (getName $1))
                                        (unLoc $2)) }

-- List containing at least 2 items
STypeCommaList2 :: { [PSType] }
    :
    SType "," rSTypeCommaList2      { $1:(reverse $3) }
rSTypeCommaList2 :: { [PSType] }
    :
    rSTypeCommaList2 "," SType      { $3:$1 }
    | SType                         { [$1] }

Literal :: { Located Literal }:
    integer_literal                 { LL (Int (getInt $1)) }
    | char_literal                  { LL (Char (getChar $1)) }
    | string_literal                { LL (String (getString $1)) }
    | "true"                        { LL (Bool True) }
    | "false"                       { LL (Bool False) }

-- We parse patterns as expressions and then transform them later
-- This is because statements are unable to determine if something is
-- a pattern or an expression without an arbitrary lookahead:
--      Pat "<-" Exp
--      Exp
Pat :: { PPat }
    :
    Exp                             { convPat $1 }

rPatList :: { [PPat] }
    :
    Pat                             { [$1] }
    | rPatList "," Pat              { $3:$1 }

BegSeq
    :
    "<"                         {% do
                                    modifyTopFileParserState (
                                        \ st @ (FileParserState { sequenceStack = (c:cs) }) -> 
                                            st { sequenceStack = (c+1):cs })
                                    return $1
                                }
EndSeq
    :
    "close_seq"                     { $1 }

-- A checked expression (that will not contain any patterns)
CExp :: { PExp }
    :
    Exp                             { checkExp $1 }

CExpList :: { [PExp] }
    :
    rCExpList                       { reverse $1 }

rCExpList :: { [PExp] }
    :
    CExp                            { [$1] }
    | rCExpList "," CExp            { $3:$1 }

-- An expression annotated with a pType
Exp :: { PExp }
    :
    ExpA                            {% do
                                        t <- freshPType
                                        let An l _ e = $1
                                        return $ An l (typeThunk, t) e
                                    }
-- An annotated expression with a dummy PType - DO NOT USE THIS
ExpA :: { PExp }
    :
    -- Basic Types
    Literal                         { LL (Lit (unLoc $1)) }
    | MaybeQualName                 { LL (Var (unLoc $1)) }
    | "(" ExpCommaList2 ")"         { AN2 (Tuple $2) }
    | Exp "." Exp                   { makeDotApp $1 $3 }

    -- Language Structure
    | "let" DeclList1 "within" Exp  { AN2 (Let (checkLetDecls $2) $4) }
    | "if" Exp "then" Exp "else" Exp { AN2 (If $2 $4 $6) }
    | "(" Exp ")"                   { AN2 (Paren $2) }
    | Exp "(" ExpCommaList ")"      { AN2 (App $1 $3) }
    | "\\" PatList "@" Exp          { AN2 (Lambda $2 $4) }

    -- Boolean ExpPatressions
    | Exp "==" Exp                  { AN2 (BooleanBinaryOp Equals $1 $3) }
    | Exp "!=" Exp                  { AN2 (BooleanBinaryOp NotEquals $1 $3) }
    | Exp "<" Exp                   { AN2 (BooleanBinaryOp LessThan $1 $3) }
    | Exp ">" Exp                   { AN2 (BooleanBinaryOp GreaterThan $1 $3) }
    | Exp "<=" Exp                  { AN2 (BooleanBinaryOp LessThanEq $1 $3) }
    | Exp ">=" Exp                  { AN2 (BooleanBinaryOp GreaterThanEq $1 $3) }
    | "not" Exp                     { AN2 (BooleanUnaryOp Not $2) } 
    | Exp "or" Exp                  { AN2 (BooleanBinaryOp Or $1 $3) }
    | Exp "and" Exp                 { AN2 (BooleanBinaryOp And $1 $3) }

    -- Arithmetic ExpPatressions
    | "-" Exp                       { AN2 (MathsUnaryOp Negate $2) }
    | Exp "+" Exp                   { AN2 (MathsBinaryOp Plus $1 $3) }
    | Exp "-" Exp                   { AN2 (MathsBinaryOp Minus $1 $3) }
    | Exp "%" Exp                   { AN2 (MathsBinaryOp Mod $1 $3) }
    | Exp "/" Exp                   { AN2 (MathsBinaryOp Divide $1 $3) }
    | Exp "*" Exp                   { AN2 (MathsBinaryOp Times $1 $3) }

    -- Sequences
    | "<>"                          { AN (List []) }
    | BegSeq ExpCommaList EndSeq    { AN2 (List $2) }
    | BegSeq ExpCommaList "|" StmtCommaList EndSeq { AN2 (ListComp $2 $4) }
    | BegSeq Exp ".." EndSeq        { AN2 (ListEnumFrom $2) }
    | BegSeq Exp ".." Exp EndSeq    { AN2 (ListEnumFromTo $2 $4) }
    | BegSeq Exp ".." "|" StmtCommaList EndSeq { AN2 (ListEnumFromComp $2 $5) }
    | BegSeq Exp ".." Exp "|" StmtCommaList EndSeq { AN2 (ListEnumFromToComp $2 $4 $6) }
    | Exp "^" Exp                   { AN2 (Concat $1 $3) }
    | "#" Exp                       { AN2 (ListLength $2) }

    -- Sets
    | "{" ExpCommaList "}"          { AN2 (Set $2) }
    | "(|" ExpMapCommaList "|)"     { AN2 (Map $2) }
    | "{" ExpCommaList "|" StmtCommaList "}" { AN2 (SetComp $2 $4) }
    | "{" Exp ".." "}"              { AN2 (SetEnumFrom $2) }
    | "{" Exp ".." Exp "}"          { AN2 (SetEnumFromTo $2 $4) }
    | "{" Exp ".." "|" StmtCommaList "}" { AN2 (SetEnumFromComp $2 $5) }
    | "{" Exp ".." Exp "|" StmtCommaList "}" { AN2 (SetEnumFromToComp $2 $4 $6) }
    | "{|" ExpCommaList "|}"        { AN2 (SetEnum $2) }
    | "{|" ExpCommaList "|" StmtCommaList "|}" { AN2 (SetEnumComp $2 $4) }

    -- Patterns
    | "_"                           { LL (ExpPatWildCard) }
    | Exp "@@" Exp                  { LL (ExpPatDoublePattern $1 $3) }

    -- Processes
    | Exp FieldList "->" Exp        { AN2 (Prefix $1 $2 $4) }
    | Exp "->" Exp                  { AN2 (Prefix $1 [] $3) }

    | Exp "[]" Exp                  { AN2 (ExternalChoice $1 $3) }
    | Exp "\\" Exp                  { AN2 (Hiding $1 $3) }
    | Exp "|~|" Exp                 { AN2 (InternalChoice $1 $3) }
    | Exp "|||" Exp                 { AN2 (Interleave $1 $3) }
    | Exp "[|" Exp "|]" Exp         { AN2 (GenParallel $1 $3 $5) }
    | Exp "[" Exp "||" Exp "]" Exp  { AN2 (AlphaParallel $1 $3 $5 $7) }
    | Exp "/\\" Exp                 { AN2 (Interrupt $1 $3) }
    | Exp "|\\" Exp                 { AN2 (Project $1 $3) }
    | Exp "[|" Exp "|>" Exp         { AN2 (Exception $1 $3 $5) }
    | Exp "[>" Exp                  { AN2 (SlidingChoice $1 $3) }
    | Exp ";" Exp                   { AN2 (SequentialComp $1 $3) }
    | Exp "&" Exp                   { AN2 (GuardedExp $1 $3) }

    | Exp "[+" Exp "+]" Exp         { AN2 (SynchronisingExternalChoice $1 $3 $5) }
    | Exp "/+" Exp "+\\" Exp        { AN2 (SynchronisingInterrupt $1 $3 $5) }

    --- TODO: check all on LHS are generators only
    -- TODO: check LHS all use <- only
    | Exp "[[" RenameList1 OptStmtList "]]" { AN2 (Rename $1 $3 $4) }
    | Exp "[" TieList1 OptStmtList "]" Exp  { AN2 (LinkParallel $1 $3 $4 $6) }

    | "|||" StmtCommaList "@" Exp   { AN2 (ReplicatedInterleave $2 $4) }
    | "[]" StmtCommaList "@" Exp    { AN2 (ReplicatedExternalChoice $2 $4) }
    | "|~|" StmtCommaList "@" Exp   { AN2 (ReplicatedInternalChoice $2 $4) }
    | "||" StmtCommaList "@" "[" Exp "]" Exp { AN2 (ReplicatedAlphaParallel $2 $5 $7) }
    | "[|" Exp "|]" StmtCommaList "@" Exp { AN2 (ReplicatedParallel $2 $4 $6) }
    | "[" TieList1 OptStmtList "]" StmtCommaList "@" Exp { AN2 (ReplicatedLinkParallel $2 $3 $5 $7) }
    | ";" StmtCommaList "@" Exp     { AN2 (ReplicatedSequentialComp $2 $4) }
    | "[+" Exp "+]" StmtCommaList "@" Exp
                                    { AN2 (ReplicatedSynchronisingExternalChoice
                                        $2 $4 $6) }

Field :: { PField }
    :
    -- For somer reason changing Exp to Pat causes a shift/reduce error, hence we do this
    "?" Exp                         { AN2 (Input (convPat $2) Nothing) }
    | "?" Exp ":" Exp               { AN2 (Input (convPat $2) (Just (checkExp $4))) }
    | "$" Exp                       { AN2 (NonDetInput (convPat $2) Nothing) }
    | "$" Exp ":" Exp               { AN2 (NonDetInput (convPat $2) (Just (checkExp $4))) }
    | "!" Exp                       { AN2 (Output (checkExp $2)) }

Rename :: { (PExp, PExp) }
    :
    CExp "<-" CExp                  { ($1, $3) }
RenameList1 :: { [(PExp, PExp)] }
    :
    rRenameList1                    { reverse $1 }
rRenameList1 :: { [(PExp, PExp)] }
    :
    Rename                          { [$1] }
    | rRenameList1 "," Rename       { $3:$1 }
Tie :: { (PExp, PExp) }
    :
    CExp "<->" CExp                 { ($1, $3) }
TieList1 :: { [(PExp, PExp)] }
    :
    rTieList1                       { reverse $1 }
rTieList1 :: { [(PExp, PExp)] }
    :
    Tie                             { [$1] }
    | rTieList1 "," Tie             { $3:$1 }

FieldList :: { [PField] }
    :
     rFieldList                     { reverse $1 }
rFieldList :: { [PField] }
    :
    Field                           { [$1] }
    | rFieldList Field              { $2:$1 }

-- List containing at least 2 items
ExpCommaList2 :: { [PExp] }
    :
    Exp "," rExpCommaList       { $1:(reverse $3) }
-- List containing at least 1 items
ExpCommaList1 :: { [PExp] }
    :
    rExpCommaList                   { reverse $1 }
ExpCommaList :: { [PExp] }
    :
                                    { [] }
    | rExpCommaList                 { reverse $1 }
rExpCommaList :: { [PExp] }
    :
    rExpCommaList "," Exp           { $3:$1 }
    | Exp                           { [$1] }

ExpMapCommaList :: { [(PExp, PExp)] }
    :
                                    { [] }
    | rExpMapCommaList              { reverse $1 }
rExpMapCommaList :: { [(PExp, PExp)] }
    :
    rExpMapCommaList "," Exp "=>" Exp   { ($3, $5):$1 }
    | Exp "=>" Exp                      { [($1, $3)] }

-- ****************************************
-- Statements
OptStmtList :: { [PStmt] }
    :
                                    { [] }
    | "|" StmtCommaList             { $2 }
Stmt :: { PStmt }
    :
    Pat "<-" CExp                   { AN2 (Generator $1 $3) }
    | Pat ":" CExp                  { AN2 (Generator $1 $3) }
    | CExp                          { AN (Qualifier $1) }
StmtCommaList :: { [PStmt] }
    :
    rStmtCommaList                  { reverse $1 }
rStmtCommaList :: { [PStmt] }
    :
    rStmtCommaList "," Stmt         { $3:$1 }
    | Stmt                          { [$1] }

{
combineDecls :: [PDecl] -> [PDecl]
combineDecls [] = []
combineDecls ((An loc1 b (FunBind n ms Nothing)):
            (An loc2 c (FunBind n1 ms1 Nothing)):ds)
        | n == n1 && srcSpanFile loc1 == srcSpanFile loc2 =
    combineDecls $
        (An (combineSpans loc1 loc2) b (FunBind n (ms++ms1) Nothing)):ds
combineDecls (d:ds) = d:combineDecls ds

constraintForName :: SrcSpan -> B.ByteString -> Constraint
constraintForName _ "Eq" = CEq
constraintForName _ "Ord" = COrd
constraintForName _ "Complete" = CComplete
constraintForName _ "Set" = CSet
constraintForName _ "Yieldable" = CYieldable
constraintForName loc s = throwSourceError [unknownConstraintError (B.unpack s) loc]

attachTypeAnnotations :: [PDecl] -> [PDecl]
attachTypeAnnotations ds =
    let
        extractTypeAnnotations :: Decl UnRenamedName ->
            [(UnRenamedName, PSTypeScheme)]
        extractTypeAnnotations (ParsedTypeAnnotation ns ta) =
            [(n, ta) | n <- ns]
        extractTypeAnnotations _ = []

        extractedAnnotations =
            concatMap (extractTypeAnnotations . unAnnotate) ds

        nameLocs :: [(UnRenamedName, SrcSpan)]
        nameLocs = [(n, loc x) | (n, x) <- extractedAnnotations]

        locForName n =
            case lookup n nameLocs of
                Just loc -> loc
                _ -> panic "Could not find name"

        locsByName :: [(UnRenamedName, [SrcSpan])]
        locsByName =
            map (\ nss -> (fst (head nss), map snd nss)) $
            groupBy (\x y -> fst x == fst y) $
            sortBy (\ x y -> compare (fst x) (fst y)) nameLocs

        dupeErrors = concatMap (\ (n, locs) ->
            case locs of
                [_] -> []
                _ -> [ambiguousTypeAnnotationsError n locs]
            ) locsByName

        nameForDecl (An _ _ (FunBind n _ _)) = [n]
        nameForDecl (An _ _ (PatBind (An _ _ (PVar n)) _ _)) = [n]
        nameForDecl (An _ _ (NameType n _ _)) = [n]
        nameForDecl (An _ _ (Channel ns _ _)) = ns
        nameForDecl (An _ _ (DataType _ cs)) = map (dataTypeClauseName . unAnnotate) cs
        nameForDecl _ = []

        allNames = nub $ sort $ map fst nameLocs
        usedNames = nub $ sort $ concatMap nameForDecl ds
        unusedNames = allNames \\ usedNames
        unusedErrors = map (\ n ->
                case lookup n nameLocs of
                    Just loc -> unusedTypeAnnotationsError n loc
                    _ -> panic "attachTypeAnnotations: logic error"
            ) unusedNames

        typeAnMap = M.fromList extractedAnnotations
            
        annotationForName n =
            M.findWithDefault (panic "attachedTypeAnnotations: invalid state")
                n typeAnMap

        annotateDecl :: PDecl -> [PDecl]
        annotateDecl (An x y (FunBind n ms Nothing)) | M.member n typeAnMap =
            [An x y (FunBind n ms (Just $ annotationForName n))]
        annotateDecl (An x y (PatBind (p@(An _ _ (PVar n))) e Nothing))
                | M.member n typeAnMap =
            [An x y (PatBind p e (Just $ annotationForName n))]
        annotateDecl (An x y (NameType n e Nothing)) | M.member n typeAnMap =
            [An x y (NameType n e (Just $ annotationForName n))]
        annotateDecl d@(An x y (Channel ns e Nothing)) | or (map (flip M.member typeAnMap) ns) =
                case ans of
                    [an] -> [An x y (Channel ns e (Just an))]
                    _ -> throwSourceError [ambiguousChannelTypeError d ns (map loc ans)]
            where ans = catMaybes $ map (flip M.lookup typeAnMap) ns
        annotateDecl (An x y (DataType n cs)) = [An x y (DataType n csP)]
            where
                annotateClause (An x y (DataTypeClause n e Nothing)) | M.member n typeAnMap =
                    An x y (DataTypeClause n e (Just $ annotationForName n))
                annotateClause d = d
                csP = map annotateClause cs
        annotateDecl (An _ _ (ParsedTypeAnnotation _ _)) = []
        annotateDecl d = [d]
    in if length dupeErrors > 0 then
            throwSourceError dupeErrors
        else if length unusedErrors > 0 then
            throwSourceError unusedErrors
        else concatMap annotateDecl ds

convDecl :: PExp -> PExp -> ParseMonad PDecl
convDecl lhs rhs | srcSpanFile (loc lhs) /= srcSpanFile (loc rhs) =
    throwSourceError [definitionSpanFileError lhs rhs (loc lhs)]
convDecl (lhs @ (An loc1 b lhsexp)) (rhs @ (An loc2 d _)) = 
    let
        span = combineSpans loc1 loc2

        -- REMEMBER: needs to reverse pts
        getPats :: Exp UnRenamedName -> ([[PPat]], UnRenamedName)
        getPats (App f args) = 
                ((map convPat args):ps, n)
            where
                (ps, n) = getPats (unAnnotate f)
        getPats (Var n) = ([], n)
        
        convFunBind exp = 
                FunBind n [An span (dummyAnnotation) (Match (reverse ps) rhs)]
                    Nothing
            where
                (ps, n) = getPats exp

        convPatBind exp = PatBind (convPat exp) rhs Nothing
    in do
        symbTable <- freshPSymbolTable
        case lhsexp of
            App f args  -> return $ An span (symbolTableThunk, symbTable) (convFunBind lhsexp)
            _           -> return $ An span (symbolTableThunk, symbTable) (convPatBind lhs)

-- | Throws an error if a declaration that is not allowed inside a let 
-- expression is found.
checkLetDecls :: [PDecl] -> [PDecl]
checkLetDecls decls =
    if and (map checkDecl decls) then
        decls
    else panic "checkLetDecls: Invalid state."
    where
        checkDecl :: PDecl -> Bool
        checkDecl (anDecl@(An _ _ decl)) =
            let
                check (FunBind _ _ _) = True
                check (PatBind _ _ _) = True
                check (External a) = True
                check (Transparent a) = True
                check (TimedSection _ _ ds) = and (map checkDecl ds)
                -- We cant allow module instances as this would cause channels
                -- to be declared in let statements, which would lead to Events
                -- being hard to define
                -- check (ModuleInstance _ _ _ _ _) = True
                check _ = throwSourceError [invalidLetDeclarationErrorMessage anDecl]
            in check decl
    
checkModuleDecl :: PDecl -> PDecl
checkModuleDecl (anDecl@(An _ _ (Assert _))) =
    throwSourceError [invalidModuleDeclarationErrorMessage anDecl]
checkModuleDecl (anDecl@(An _ _ (PrintStatement _))) =
    throwSourceError [invalidModuleDeclarationErrorMessage anDecl]
checkModuleDecl (anDecl@(An x y (TimedSection a b ds))) =
    An x y (TimedSection a b (map checkModuleDecl ds))
checkModuleDecl d = d

checkTimedDecl :: PDecl -> PDecl
checkTimedDecl (anDecl@(An _ _ (PrintStatement _))) =
    throwSourceError [invalidTimedSectionDeclarationErrorMessage anDecl]
checkTimedDecl d = d

-- Transform X \ Y ||| Z (which will have been parsed as X \ (Y ||| Z)) into
-- (X \ Y) ||| Z (and ditto for other parallel operators). Note that we cannot
-- do this using precedences, since we do want X ||| Y \ Z to bracket \ Z around
-- the whole of X ||| Y. Thus, we really need a context dependent precedence,
-- which happy doesnt have.
transformHideProject :: PExp -> PExp
transformHideProject exp =
    let
        extractLeft (An _ _ (Interleave e _)) = e
        extractLeft (An _ _ (GenParallel e _ _)) = e
        extractLeft (An _ _ (AlphaParallel e _ _ _)) = e
        extractLeft (An _ _ (Exception e _ _)) = e
        extractLeft (An _ _ (InternalChoice e _)) = e
        extractLeft (An _ _ (ExternalChoice e _)) = e
        extractLeft (An _ _ (Interrupt e _)) = e
        extractLeft (An _ _ (SlidingChoice e _)) = e
        extractLeft (An _ _ (SequentialComp e _)) = e
        extractLeft (An _ _ (SynchronisingExternalChoice e _ _)) = e
        extractLeft (An _ _ (SynchronisingInterrupt e _ _)) = e

        transform :: SrcSpan -> PExp -> PExp -> PExp
        transform loc newLeft (An _ an1 (Interleave _ e3)) =
            An loc an1 (Interleave newLeft e3)
        transform loc newLeft (An _ an1 (GenParallel _ e3 e4)) =
            An loc an1 (GenParallel newLeft e3 e4)
        transform loc newLeft (An _ an1 (AlphaParallel _ e3 e4 e5)) =
            An loc an1 (AlphaParallel newLeft e3 e4 e5)
        transform loc newLeft (An _ an1 (Exception _ e3 e4)) =
            An loc an1 (Exception newLeft e3 e4)
        transform loc newLeft (An _ an1 (InternalChoice _ e3)) =
            An loc an1 (InternalChoice newLeft e3)
        transform loc newLeft (An _ an1 (ExternalChoice _ e3)) =
            An loc an1 (ExternalChoice newLeft e3)
        transform loc newLeft (An _ an1 (Interrupt _ e3)) =
            An loc an1 (Interrupt newLeft e3)
        transform loc newLeft (An _ an1 (SlidingChoice _ e3)) =
            An loc an1 (SlidingChoice newLeft e3)
        transform loc newLeft (An _ an1 (SequentialComp _ e3)) =
            An loc an1 (SequentialComp newLeft e3)
        transform loc newLeft (An _ an1 (SynchronisingExternalChoice _ e2 e3)) =
            An loc an1 (SynchronisingExternalChoice newLeft e2 e3)
        transform loc newLeft (An _ an1 (SynchronisingInterrupt _ e2 e3)) =
            An loc an1 (SynchronisingInterrupt newLeft e2 e3)

        shouldTransform (An _ _ (Interleave _ _)) = True
        shouldTransform (An _ _ (Interleave _ _)) = True
        shouldTransform (An _ _ (GenParallel _ _ _)) = True
        shouldTransform (An _ _ (AlphaParallel _ _ _ _)) = True
        shouldTransform (An _ _ (Exception _ _ _)) = True
        shouldTransform (An _ _ (InternalChoice _ _)) = True
        shouldTransform (An _ _ (ExternalChoice _ _)) = True
        shouldTransform (An _ _ (Interrupt _ _)) = True
        shouldTransform (An _ _ (SlidingChoice _ _)) = True
        shouldTransform (An _ _ (SequentialComp _ _)) = True
        shouldTransform (An _ _ (SynchronisingExternalChoice _ _ _)) = True
        shouldTransform (An _ _ (SynchronisingInterrupt _ _ _)) = True
        shouldTransform _ = False
    in
        case exp of
            An l1 an1 (Hiding e1 e2) | shouldTransform e2 ->
                let
                    newHideArg = extractLeft e2
                    lhide = combineSpans (loc e1) (loc newHideArg)
                in transform l1 (An lhide an1 (Hiding e1 newHideArg)) e2
            An l1 an1 (Project e1 e2) | shouldTransform e2 ->
                let
                    newHideArg = extractLeft e2
                    lhide = combineSpans (loc e1) (loc newHideArg)
                in transform l1 (An lhide an1 (Project e1 newHideArg)) e2
            _ -> exp

checkExp :: PExp -> PExp
checkExp anExp =
    let 
        check :: Exp UnRenamedName -> Exp UnRenamedName
        check (App e es) = App (checkExp e) (map checkExp es)
        check (BooleanBinaryOp op e1 e2) = BooleanBinaryOp op (checkExp e1) (checkExp e2)
        check (BooleanUnaryOp op e) = BooleanUnaryOp op (checkExp e)
        check (Concat e1 e2) = Concat (checkExp e1) (checkExp e2)
        check (DotApp e1 e2) = DotApp (checkExp e1) (checkExp e2)
        check (If e1 e2 e3) = If (checkExp e1) (checkExp e2) (checkExp e3)
        check (Lambda p e) = Lambda p (checkExp e)
        check (Let decls e) = Let decls (checkExp e)
        check (Lit lit) = Lit lit
        check (List es) = List (map checkExp es)
        check (ListComp es stmts) = ListComp (map checkExp es) stmts
        check (ListEnumFrom e) = ListEnumFrom (checkExp e)
        check (ListEnumFromTo e1 e2) = ListEnumFromTo (checkExp e1) (checkExp e2)
        check (ListEnumFromComp e1 stmts) = ListEnumFromComp (checkExp e1) stmts
        check (ListEnumFromToComp e1 e2 stmts) =
            ListEnumFromToComp (checkExp e1) (checkExp e2) stmts
        check (ListLength e) = ListLength (checkExp e)
        check (Map kvs) = Map (map (\ (k, v) -> (checkExp k, checkExp v)) kvs)
        check (MathsBinaryOp op e1 e2) = MathsBinaryOp op (checkExp e1) (checkExp e2)
        check (MathsUnaryOp op e) = MathsUnaryOp op (checkExp e)
        check (Paren e) = Paren (checkExp e)
        check (Set es) = Set (map checkExp es)
        check (SetComp es stmts) = SetComp (map checkExp es) stmts
        check (SetEnumFrom e) = SetEnumFrom (checkExp e)
        check (SetEnumFromTo e1 e2) = SetEnumFromTo (checkExp e1) (checkExp e2)
        check (SetEnumFromComp e1 stmts) = SetEnumFromComp (checkExp e1) stmts
        check (SetEnumFromToComp e1 e2 stmts) =
            SetEnumFromToComp (checkExp e1) (checkExp e2) stmts
        check (SetEnum es) = SetEnum (map checkExp es)
        -- We dont need to check inside stmts as they will have been checked
        -- upon creation
        check (SetEnumComp es stmts) = SetEnumComp (map checkExp es) stmts
        check (Tuple es) = Tuple (map checkExp es)
        check (Var qname) = Var qname

        check (AlphaParallel e1 e2 e3 e4) = 
            AlphaParallel (checkExp e1) (checkExp e2) (checkExp e3) (checkExp e4)
        check (Exception e1 e2 e3) = Exception (checkExp e1) (checkExp e2) (checkExp e3)
        check (ExternalChoice e1 e2) = ExternalChoice (checkExp e1) (checkExp e2)
        check (GenParallel e1 e2 e3) = GenParallel (checkExp e1) (checkExp e2) (checkExp e3)
        check (GuardedExp e1 e2) = GuardedExp (checkExp e1) (checkExp e2)
        check (Hiding e1 e2) = Hiding (checkExp e1) (checkExp e2)
        check (InternalChoice e1 e2) = InternalChoice (checkExp e1) (checkExp e2)
        check (Interrupt e1 e2) = Interrupt (checkExp e1) (checkExp e2)
        check (Interleave e1 e2) = Interleave (checkExp e1) (checkExp e2)
        check (LinkParallel e1 ties stmts e2) = 
            LinkParallel (checkExp e1) ties stmts (checkExp e2)
        check (Prefix e1 fields e2) = Prefix (checkExp e1) fields (checkExp e2)
        check (Project e1 e2) = Project (checkExp e1) (checkExp e2)
        check (Rename e ties stmts) = Rename (checkExp e) ties stmts
        check (SequentialComp e1 e2) = SequentialComp (checkExp e1) (checkExp e2)
        check (SlidingChoice e1 e2) = SlidingChoice (checkExp e1) (checkExp e2)
        check (SynchronisingExternalChoice e1 e2 e3) =
            SynchronisingExternalChoice (checkExp e1) (checkExp e2) (checkExp e3)
        check (SynchronisingInterrupt e1 e2 e3) =
            SynchronisingInterrupt (checkExp e1) (checkExp e2) (checkExp e3)

        check (ReplicatedAlphaParallel stmts e1 e2) = 
            ReplicatedAlphaParallel stmts (checkExp e1) (checkExp e2)
        check (ReplicatedInterleave stmts e1) = ReplicatedInterleave stmts (checkExp e1)
        check (ReplicatedExternalChoice stmts e1) = ReplicatedExternalChoice stmts (checkExp e1)
        check (ReplicatedInternalChoice stmts e1) = ReplicatedInternalChoice stmts (checkExp e1)
        check (ReplicatedParallel e1 stmts e2) = 
            ReplicatedParallel (checkExp e1) stmts (checkExp e2)
        check (ReplicatedLinkParallel ties tiesStmts stmts e) = 
            ReplicatedLinkParallel ties tiesStmts stmts (checkExp e)
        check (ReplicatedSequentialComp stmts e1) = 
            ReplicatedSequentialComp stmts (checkExp e1)
        check (ReplicatedSynchronisingExternalChoice e1 stmts e3) =
            ReplicatedSynchronisingExternalChoice (checkExp e1) stmts
                (checkExp e3)
        
        check x = throwSourceError [invalidExpressionErrorMessage anExp]
    in
        case transformHideProject anExp of
            An a b exp -> An a b (check exp)

getFuncArgs :: PSType -> [PSType]
getFuncArgs (An _ _ (STParen s)) = [s]
getFuncArgs (An _ _ (STTuple ts)) = ts
getFuncArgs s = throwSourceError [invalidFunctionArgsErrorMessage s]

dotAppToList :: PExp -> [PExp]
dotAppToList (An a b exp) = 
    let 
        list :: Exp UnRenamedName -> [PExp]
        list (DotApp e1 e2) = (dotAppToList e1) ++ (dotAppToList e2)
        list x = [An a b x]
    in
        list exp

convPat :: PExp -> PPat
convPat (anExp@ (An a b exp)) = 
    let
        trans :: Exp UnRenamedName -> Pat UnRenamedName
        trans (Concat e1 e2) = PConcat (convPat e1) (convPat e2)
        trans (DotApp e1 e2) = PDotApp (convPat e1) (convPat e2)
        trans (List xs) = PList (map convPat xs)
        trans (Lit x) = PLit x
        trans (MathsUnaryOp Negate e) =
            case trans (unAnnotate e) of
                PLit (Int x) -> PLit (Int (-x))
                _ -> throwSourceError [invalidPatternErrorMessage anExp]
        trans (Set xs) = PSet (map convPat xs)
        trans (Paren x) = PParen (convPat x)
        trans (Tuple xs) = PTuple (map convPat xs)
        trans (Var x) = PVar x
        trans (ExpPatWildCard) = PWildCard
        trans (ExpPatDoublePattern e1 e2) = 
            PDoublePattern (convPat e1) (convPat e2)
        trans x = throwSourceError [invalidPatternErrorMessage anExp]
    in
        An a b (trans exp)

checkModelOptions :: [PModelOption] -> [PModelOption]
checkModelOptions options =
    let
        cmp (PartialOrderReduce _) (PartialOrderReduce _) = EQ
        cmp (PartialOrderReduce _) _ = LT
        cmp _ (PartialOrderReduce _) = GT

        cmp (TauPriority _) (TauPriority _) = EQ
        cmp (TauPriority _) _ = LT
        cmp _ (TauPriority _) = GT

        optionGroups = groupBy (\ x y -> cmp (unAnnotate x) (unAnnotate y) == EQ)
            (sortBy (\ x y -> cmp (unAnnotate x) (unAnnotate y)) options)
        nonTrivialGroups = filter (\ xs -> length xs /= 1) optionGroups
    in
        case nonTrivialGroups of
            [] -> options
            g:_ -> throwSourceError [duplicateModelOptionsError g]

stripParen :: PExp -> PExp
stripParen (An _ _ (Paren e)) = stripParen e
stripParen e = e

makeDotApp :: PExp -> PExp -> PExp
makeDotApp e1 e3 =
    case stripParen e1 of
        An _ typ (DotApp e1 e2) -> annotate2 e1 right $ DotApp e1 right
            where
                An loc _ rightP = annotate2 e2 e3 $ DotApp e2 e3
                right = An loc typ rightP
        _ -> annotate2 e1 e3 (DotApp e1 e3)

makeSTDot :: PSType -> PSType -> PSType
makeSTDot (An loc typ (STDot e1 e2)) e3 = annotate2 e1 right $ STDot e1 right
    where right = annotate2 e2 e3 $ STDot e2 e3
makeSTDot e1 e2 = annotate2 e1 e2 (STDot e1 e2)


-- Helper function to get the contents of tokens
getInt (L _ (TInteger x)) = x
getChar (L _ (TChar c)) = c
getString (L _ (TString s)) = s
getName (L _ (TIdent x)) = x
getRefinesModel (L _ (TRefines x)) = x
getPropModel (L _ (TModel x)) = x
getPrintString (L _ (TPrint x)) = x
getStringOption (L _ (TStringOption x)) = x

class Locatable a where
    getLoc :: a b -> SrcSpan
    unLoc :: a b -> b
    mkLoc :: SrcSpan -> b -> a b

instance Locatable Located where
    getLoc (L loc _) = loc
    unLoc (L _ b) = b
    mkLoc loc b = L loc b

instance Locatable (Annotated a) where
    getLoc (An loc _ _) = loc
    unLoc (An _ _ b) = b
    mkLoc loc b = An loc dummyAnnotation b

annotate :: (Locatable t1, Locatable t2) => t1 a -> b -> t2 b
annotate t1 b = mkLoc (getLoc t1) b

annotate2 :: 
    (Locatable t1, Locatable t2, Locatable t3) => t1 a -> t2 b -> c -> t3 c
annotate2 t1 t2 b = mkLoc (combineSpans (getLoc t1) (getLoc t2)) b
annotate2List :: 
    (Locatable t1, Locatable t2, Locatable t3) => t1 a -> [t2 b] -> c -> t3 c
annotate2List t1 [] b = mkLoc (getLoc t1) b
annotate2List t1 t2 b = annotate2 t1 (last t2) b
annotate2Lista :: 
    (Locatable t1, Locatable t2, Locatable t3) => [t1 a] -> t2 b -> c -> t3 c
annotate2Lista t1 t2 b = annotate2 (last t1) t2 b

symbolTableThunk = panic "Symbol table not typechecked yet"
typeThunk = panic "Type not typechecked yet"

annotateWithSymbolTable 
    :: Annotated (SymbolTable, PSymbolTable) a -> ParseMonad (Annotated (SymbolTable, PSymbolTable) a)
annotateWithSymbolTable (An l _ a) = do
    symbTable <- freshPSymbolTable
    return $ An l (symbolTableThunk, symbTable) a

liftLoc :: (Locatable t1, Locatable t2) => t1 a -> b -> t2 b
liftLoc t1 b = mkLoc (getLoc t1) b

parseError :: LToken -> ParseMonad a
parseError tok = throwSourceError [parseErrorMessage tok]
}
