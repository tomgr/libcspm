{
module CSPM.Parser.Parser (
    parseFile_, parseInteractiveStmt_, parseExpression_
) 
where

-- To generate the corresponding .hs file run the following commands
-- cpp -P src/CSPM/Parser/Parser.ppy > src/CSPM/Parser/Parser.y
-- happy --ghc --coerce --array src/CSPM/Parser/Parser.y
-- rm src/CSPM/Parser/Parser.y

-- i.e.: cpp -P src/CSPM/Parser/Parser.ppy > src/CSPM/Parser/Parser.y && happy --ghc --coerce --array src/CSPM/Parser/Parser.y && rm src/CSPM/Parser/Parser.y

import Data.Char
import Data.List (groupBy, nub, sort, sortBy, (\\))
import qualified Data.Map as M

import CSPM.DataStructures.Literals
import CSPM.DataStructures.Names
import CSPM.DataStructures.Syntax
import CSPM.DataStructures.Types hiding (TDot, TChar)
import CSPM.Parser.Exceptions
import CSPM.Parser.Lexer
import CSPM.Parser.Monad
import CSPM.Parser.Tokens
import Prelude hiding (getChar)
import Util.Annotated
import Util.Exception (panic)
}

-- Lift the src span from $1 to the resulting token
-- (i.e. LL (LLit ...) (Exp ...) = LExp ...
#define LL liftLoc $1
-- Make a src span from the first item to the last
#define AN annotate $1
#define AN2 annotate2 $1 $>
#define AN2L annotate2List $1 $>
#define AN2LL annotate2Lista $1 $>

%name parseFile_ CSPMFile
%name parseInteractiveStmt_ InteractiveStmt
%name parseExpression_ CExp
%lexer { getNextTokenWrapper } { L _ TEOF }
%monad { ParseMonad }
%tokentype { LToken }
%error { parseError }
%token
    integer_literal     { L _ (TInteger _) }
    char_literal        { L _ (TChar _) }
    string_literal      { L _ (TString _) }
    ident               { L _ (TIdent _) }
    newline             { L _ TNewLine }
    print_literal       { L _ (TPrint _) }

    "false"             { L _ TFalse }
    "true"              { L _ TTrue }

    "="                 { L _ TDefineEqual }

    ","                 { L _ TComma }
    "."                 { L _ TDot }
    "?"                 { L _ TQuestionMark }
    "$"                 { L _ TDollar }
    "!"                 { L _ TExclamationMark }
    ".."                { L _ TDoubleDot }
    ":"                 { L _ TColon }
    "<-"                { L _ TDrawnFrom }
    "<->"               { L _ TTie }
    "|"                 { L _ TPipe }

    "@@"                { L _ TDoubleAt }
    "_"                 { L _ TWildCard }

    "if"                { L _ TIf }
    "then"              { L _ TThen }
    "else"              { L _ TElse }
    "let"               { L _ TLet }
    "within"            { L _ TWithin }
    "\\"                { L _ TBackSlash }
    "@"                 { L _ TLambdaDot }
    "channel"           { L _ TChannel }
    "datatype"          { L _ TDataType }
    "subtype"           { L _ TSubType }
    "external"          { L _ TExternal }
    "transparent"       { L _ TTransparent }
    "nametype"          { L _ TNameType }
    "module"            { L _ TModule }
    "exports"           { L _ TExports }
    "endmodule"         { L _ TEndModule }
    "instance"          { L _ TInstance }
    "::"                { L _ TScope }
    "Timed"             { L _ TTimed }

    OfType              { L _ TOfType }
    "=>"                { L _ TYield }
    "=>*"               { L _ TYieldStar }

    "assert"            { L _ TAssert }
    "deadlock free"     { L _ TDeadlockFree }
    "livelock free"     { L _ TLivelockFree }
    "divergence free"   { L _ TDivergenceFree }
    "deterministic"     { L _ TDeterministic }
    "tau priority"      { L _ TTauPriority }
    refines             { L _ (TRefines _) }
    model               { L _ (TModel _) }
    
    "not"               { L _ TNot }
    "anot"              { L _ TAssertNot }
    "and"               { L _ TAnd }
    "or"                { L _ TOr }
    "=="                { L _ TEq }
    "!="                { L _ TNotEq }
    "<="                { L _ TLtEq }
    ">="                { L _ TGtEq }
    "<>"                { L _ TEmptySeq }
    "<"                 { L _ TLt }
    ">"                 { L _ TGt }
    "close_seq"         { L _ TCloseSeq }

    "+"                 { L _ TPlus }
    "-"                 { L _ TMinus }
    "*"                 { L _ TTimes }
    "/"                 { L _ TDivide }
    "%"                 { L _ TMod }

    "^"                 { L _ TConcat }
    "#"                 { L _ THash }

    "("                 { L _ TLParen }
    ")"                 { L _ TRParen }
    "{"                 { L _ TLBrace }
    "}"                 { L _ TRBrace }
    "(|"                { L _ TLMap }
    "|)"                { L _ TRMap }
    "{|"                { L _ TLPipeBrace }
    "|}"                { L _ TRPipeBrace }
    "[["                { L _ TLDoubleSqBracket }
    "]]"                { L _ TRDoubleSqBracket }
    "[|"                { L _ TLPipeSqBracket }
    "|]"                { L _ TRPipeSqBracket }
    "["                 { L _ TLSqBracket }
    "]"                 { L _ TRSqBracket }

    "[]"                { L _ TExtChoice }
    "|~|"               { L _ TIntChoice }
    "|||"               { L _ TInterleave }
    "->"                { L _ TPrefix }
    "/\\"               { L _ TInterrupt }
    "[>"                { L _ TSlidingChoice }
    "|>"                { L _ TRException }
    "||"                { L _ TParallel }
    ";"                 { L _ TSemiColon }
    "&"                 { L _ TGuard }

    "[+"                { L _ TLSyncExtChoice }
    "+]"                { L _ TRSyncExtChoice }
    "/+"                { L _ TLSyncInterrupt }
    "+\\"               { L _ TRSyncInterrupt }

-- TODO: lambda dot
%nonassoc "let" "within" "@" "if" "then" "else"
%nonassoc "@@" --COLON AT AS
%left "\\"
%left "|||"
%nonassoc "|>" "[|" "|]" "[" "]" "||" --"[[" "]]" -- PROB
%left "|~|"
%left "[]" "[+" "+]"
%left "/\\" "/+" "+\\"
%left "[>"
%left ";"
%right "&" "->" --GUARD WHERESQ (this is &[)
%left "?" "!" "$"
%right "=>" "=>*"
%right "."  -- TODO: correct?
%nonassoc ":"
%left "or"
%left "and"
%left "not"
%nonassoc "==" "!=" "<" "<=" ">" ">="
%left "+" "-"
%left "*" "/" "%"
%left "#"
%left "^"
%nonassoc "(" ")" "[[" "]]"
%nonassoc "::"

%%

CSPMFile :: { PCSPMFile }
    :
    Newlines0 DeclList                          { mkLoc Unknown (CSPMFile $2) }
    
InteractiveStmt :: { PInteractiveStmt }
    :
    "let" Exp "=" CExp                          {% do
                                                    d <- convDecl $2 $4 
                                                    d <- annotateWithSymbolTable d
                                                    return $ AN2 (Bind [d])}
    | "assert" "anot" Assertion                 { AN2 (RunAssertion (AN2 (ASNot $3))) }
    | "assert" Assertion                        { AN2 (RunAssertion $2) }
    | "external" NameCommaList1                 {% do
                                                    d <- annotateWithSymbolTable $
                                                        AN2L (External (map unLoc $2))
                                                    return $ AN2L (Bind [d]) }
    | "transparent" NameCommaList1              {% do
                                                    d <- annotateWithSymbolTable $
                                                        AN2L (Transparent (map unLoc $2))
                                                    return $ AN2L (Bind [d]) }
    | CExp                                      { AN (Evaluate $1) }

Newlines :
    newline                                     { }
    | Newlines newline                          { }
Newlines0 :
                                                { }
    | Newlines0 newline                         { }

DeclList :: { [PDecl] }
    :
                                                { [] }
    | DeclList1                                 { $1 }
DeclList1 :: { [PDecl] }
    :
    rDeclList1NC                                { attachTypeAnnotations $
                                                    combineDecls (reverse $1) }
rDeclList1NC :: { [PDecl] }
    :
    Decl                                        { [$1] }
    | rDeclList1NC Newlines MaybeDecl           { case $3 of 
                                                    Just d -> d:$1
                                                    Nothing -> $1 }
MaybeDecl :: { Maybe PDecl }
    :
                                                { Nothing }
    | Decl                                      { Just $1 }

Decl :: { PDecl }
    :
    DeclA                                       {% annotateWithSymbolTable $1 }
DeclA :: { PDecl }
    :
    Exp "=" CExp                                {% convDecl $1 $3 }
    | "channel" NameCommaList1                  { AN2L (Channel (map unLoc $2) Nothing) }
    | "channel" NameCommaList1 ":" CExp         { AN2 (Channel (map unLoc $2) (Just $4)) }
    | "datatype" Name "=" DataTypeClauseList1   { AN2L (DataType (unLoc $2) $4) }
    | "subtype" Name "=" DataTypeClauseList1    { AN2L (SubType (unLoc $2) $4) }
    | "external" NameCommaList1                 { AN2L (External (map unLoc $2)) }
    | "transparent" NameCommaList1              { AN2L (Transparent (map unLoc $2)) }
    | "assert" "anot" Assertion                 { AN2 (Assert (AN2 (ASNot $3))) }
    | "assert" Assertion                        { AN2 (Assert $2) }
    | "nametype" Name "=" CExp                  { AN2 (NameType (unLoc $2) $4) }
    | "module" Name OptPatList Newlines DeclList
      "exports" Newlines DeclList "endmodule"    { AN2 (Module (unLoc $2) $3 
                                                    (map checkModuleDecl $5)
                                                    (map checkModuleDecl $8)) }
    | "Timed" "{" DeclList "}"                  { AN2 (TimedSection Nothing
                                                    Nothing
                                                    (map checkTimedDecl $3)) }
    | "Timed" "(" CExp ")" "{" DeclList "}"     { AN2 (TimedSection Nothing
                                                    (Just $3)
                                                    (map checkTimedDecl $6)) }
    | NameCommaList1 OfType STypeScheme         { AN2LL (ParsedTypeAnnotation
                                                    (map unLoc $1) $3) }
    | "instance" Name "=" MaybeQualName ExpList { AN2L (ModuleInstance (unLoc $2)
                                                    (unLoc $4) $5 [] Nothing) }
    | "instance" Name "=" MaybeQualName         { AN2 (ModuleInstance (unLoc $2)
                                                    (unLoc $4) [] [] Nothing) }
    | print_literal                             { LL (PrintStatement
                                                    (getPrintString $1)) }

OptPatList :: { [PPat] }
    :
                                                { [] }
    | "(" rPatList ")"                          { reverse $2 }

PatList :: { [PPat] }
    :
    rPatList                                    { reverse $1 }

ExpList :: { [PExp] }
    :
    "(" CExpList ")"                            { reverse $2 }

Assertion :: { PAssertion }
    :
    CExp refines CExp                       { AN2 (Refinement $1 (getRefinesModel $2) $3 []) }
    | CExp refines CExp ModelOption         { AN2 (Refinement $1 (getRefinesModel $2) $3 [unLoc $4]) }
    | CExp SemanticProperty                 { AN2 (PropertyCheck $1 (unLoc $2) Nothing) }
    | CExp SemanticProperty model           { AN2 (PropertyCheck $1 (unLoc $2) (Just (getPropModel $3))) }
SemanticProperty :: { Located SemanticProperty }
    :
    "deadlock free"                             { LL DeadlockFreedom }
    | "livelock free"                           { LL LivelockFreedom }
    | "divergence free"                         { LL LivelockFreedom }
    | "deterministic"                           { LL Deterministic }

ModelOption :: { Located (ModelOption UnRenamedName) }
    :
    "tau priority" CExp                         { AN2 (TauPriority $2) }

DataTypeClause :: { PDataTypeClause }
    :
    Name "." CExp                               { AN2 (DataTypeClause (unLoc $1) (Just $3)) }
    | Name                                      { AN (DataTypeClause (unLoc $1) Nothing) }
DataTypeClauseList1 :: { [PDataTypeClause] }
    :
    rDataTypeClauseList                         { reverse $1 }
rDataTypeClauseList :: { [PDataTypeClause] }
    :
    DataTypeClause                              { [$1] }
    | rDataTypeClauseList "|" DataTypeClause    { $3:$1 }

MaybeQualName :: { Located UnRenamedName }
    : 
    ident                           { LL (UnQual (OccName (getName $1))) }
    | ident "::" MaybeQualName      { AN (Qual (OccName (getName $1)) (unLoc $3)) }

Name :: { Located UnRenamedName }
    : 
    ident                           { LL (UnQual (OccName (getName $1))) }

NameCommaList1 :: { [Located UnRenamedName] }
    :
    rNameCommaList                  { reverse $1 }
rNameCommaList :: { [Located UnRenamedName] }
    :
    Name                            { [$1] }
    | rNameCommaList "," Name       { $3:$1 }

STypeScheme :: { PSTypeScheme }
    :
    SType                                       { LL (STypeScheme [] [] $1) }
    | STypeConstraint "=>" SType                { LL (STypeScheme [] [$1] $3) }
    | "(" STypeConstraint1 ")" "=>" SType       { LL (STypeScheme [] $2 $5) }

STypeConstraint1 :: { [PSTypeConstraint] }
    :
    rSTypeConstraintList1                       { reverse $1 }
rSTypeConstraintList1 :: { [PSTypeConstraint] }
    :
    rSTypeConstraintList1 "," STypeConstraint   { $3:$1 }
    | STypeConstraint                           { [$1] }

SType :: { PSType }
    :
    MaybeQualName                   { LL (STVar (unLoc $1)) }
    | "{" SType "}"                 { AN2 (STSet $2) }
    | "<" SType ">"                 { AN2 (STSeq $2) }
    | "(" SType ")"                 { AN2 (STParen $2) }
    | MaybeQualName "=>*" SType     { AN2 (STExtendable $3 (unLoc $1)) }
    | SType "=>" SType              { AN2 (STDotable $1 $3) }
    | "(|" SType "=>" SType "|)"    { AN2 (STMap $2 $4) }
    | SType "." SType               { makeSTDot $1 $3 }
    | "(" STypeCommaList2 ")"       { AN2 (STTuple $2) }
    | "(" ")" "->" SType            { AN2 (STFunction [] $4) }
    | SType "->" SType              { AN2 (STFunction
                                        (getFuncArgs $1) $3) }

STypeConstraint :: { PSTypeConstraint }
    :
    ident Name                      { AN2 (STypeConstraint
                                        (constraintForName (getLoc $1)
                                            (getName $1))
                                        (unLoc $2)) }

-- List containing at least 2 items
STypeCommaList2 :: { [PSType] }
    :
    SType "," rSTypeCommaList2      { $1:(reverse $3) }
rSTypeCommaList2 :: { [PSType] }
    :
    rSTypeCommaList2 "," SType      { $3:$1 }
    | SType                         { [$1] }

Literal :: { Located Literal }:
    integer_literal                 { LL (Int (getInt $1)) }
    | char_literal                  { LL (Char (getChar $1)) }
    | string_literal                { LL (String (getString $1)) }
    | "true"                        { LL (Bool True) }
    | "false"                       { LL (Bool False) }

-- We parse patterns as expressions and then transform them later
-- This is because statements are unable to determine if something is
-- a pattern or an expression without an arbitrary lookahead:
--      Pat "<-" Exp
--      Exp
Pat :: { PPat }
    :
    Exp                             { convPat $1 }

rPatList :: { [PPat] }
    :
    Pat                             { [$1] }
    | rPatList "," Pat              { $3:$1 }

BegSeq
    :
    "<"                         {% do
                                    modifyTopFileParserState (
                                        \ st @ (FileParserState { sequenceStack = (c:cs) }) -> 
                                            st { sequenceStack = (c+1):cs })
                                    return $1
                                }
EndSeq
    :
    "close_seq"                     { $1 }

-- A checked expression (that will not contain any patterns)
CExp :: { PExp }
    :
    Exp                             { checkExp $1 }

CExpList :: { [PExp] }
    :
    rCExpList                       { reverse $1 }

rCExpList :: { [PExp] }
    :
    CExp                            { [$1] }
    | rCExpList "," CExp            { $3:$1 }

-- An expression annotated with a pType
Exp :: { PExp }
    :
    ExpA                            {% do
                                        t <- freshPType
                                        let An l _ e = $1
                                        return $ An l (Nothing, t) e
                                    }
-- An annotated expression with a dummy PType - DO NOT USE THIS
ExpA :: { PExp }
    :
    -- Basic Types
    Literal                         { LL (Lit (unLoc $1)) }
    | MaybeQualName                 { LL (Var (unLoc $1)) }
    | "(" ExpCommaList2 ")"         { AN2 (Tuple $2) }
    | Exp "." Exp                   { makeDotApp $1 $3 }

    -- Language Structure
    | "let" DeclList1 "within" Exp  { AN2 (Let (checkLetDecls $2) $4) }
    | "if" Exp "then" Exp "else" Exp { AN2 (If $2 $4 $6) }
    | "(" Exp ")"                   { AN2 (Paren $2) }
    | Exp "(" ExpCommaList ")"      { AN2 (App $1 $3) }
    | "\\" PatList "@" Exp          { AN2 (Lambda $2 $4) }

    -- Boolean ExpPatressions
    | Exp "==" Exp                  { AN2 (BooleanBinaryOp Equals $1 $3) }
    | Exp "!=" Exp                  { AN2 (BooleanBinaryOp NotEquals $1 $3) }
    | Exp "<" Exp                   { AN2 (BooleanBinaryOp LessThan $1 $3) }
    | Exp ">" Exp                   { AN2 (BooleanBinaryOp GreaterThan $1 $3) }
    | Exp "<=" Exp                  { AN2 (BooleanBinaryOp LessThanEq $1 $3) }
    | Exp ">=" Exp                  { AN2 (BooleanBinaryOp GreaterThanEq $1 $3) }
    | "not" Exp                     { AN2 (BooleanUnaryOp Not $2) } 
    | Exp "or" Exp                  { AN2 (BooleanBinaryOp Or $1 $3) }
    | Exp "and" Exp                 { AN2 (BooleanBinaryOp And $1 $3) }

    -- Arithmetic ExpPatressions
    | "-" Exp                       { AN2 (MathsUnaryOp Negate $2) }
    | Exp "+" Exp                   { AN2 (MathsBinaryOp Plus $1 $3) }
    | Exp "-" Exp                   { AN2 (MathsBinaryOp Minus $1 $3) }
    | Exp "%" Exp                   { AN2 (MathsBinaryOp Mod $1 $3) }
    | Exp "/" Exp                   { AN2 (MathsBinaryOp Divide $1 $3) }
    | Exp "*" Exp                   { AN2 (MathsBinaryOp Times $1 $3) }

    -- Sequences
    | "<>"                          { AN (List []) }
    | BegSeq ExpCommaList EndSeq    { AN2 (List $2) }
    | BegSeq ExpCommaList "|" StmtCommaList EndSeq { AN2 (ListComp $2 $4) }
    | BegSeq Exp ".." EndSeq        { AN2 (ListEnumFrom $2) }
    | BegSeq Exp ".." Exp EndSeq    { AN2 (ListEnumFromTo $2 $4) }
    | BegSeq Exp ".." "|" StmtCommaList EndSeq { AN2 (ListEnumFromComp $2 $5) }
    | BegSeq Exp ".." Exp "|" StmtCommaList EndSeq { AN2 (ListEnumFromToComp $2 $4 $6) }
    | Exp "^" Exp                   { AN2 (Concat $1 $3) }
    | "#" Exp                       { AN2 (ListLength $2) }

    -- Sets
    | "{" ExpCommaList "}"          { AN2 (Set $2) }
    | "(|" ExpMapCommaList "|)"     { AN2 (Map $2) }
    | "{" ExpCommaList "|" StmtCommaList "}" { AN2 (SetComp $2 $4) }
    | "{" Exp ".." "}"              { AN2 (SetEnumFrom $2) }
    | "{" Exp ".." Exp "}"          { AN2 (SetEnumFromTo $2 $4) }
    | "{" Exp ".." "|" StmtCommaList "}" { AN2 (SetEnumFromComp $2 $5) }
    | "{" Exp ".." Exp "|" StmtCommaList "}" { AN2 (SetEnumFromToComp $2 $4 $6) }
    | "{|" ExpCommaList "|}"        { AN2 (SetEnum $2) }
    | "{|" ExpCommaList "|" StmtCommaList "|}" { AN2 (SetEnumComp $2 $4) }

    -- TODO: disallow these in expressions
    -- Patterns
    | "_"                           { LL (ExpPatWildCard) }
    | Exp "@@" Exp                  { LL (ExpPatDoublePattern $1 $3) }

    -- Processes
    | Exp FieldList "->" Exp        { AN2 (Prefix $1 $2 $4) }
    | Exp "->" Exp                  { AN2 (Prefix $1 [] $3) }

    | Exp "[]" Exp                  { AN2 (ExternalChoice $1 $3) }
    | Exp "\\" Exp                  { AN2 (Hiding $1 $3) }
    | Exp "|~|" Exp                 { AN2 (InternalChoice $1 $3) }
    | Exp "|||" Exp                 { AN2 (Interleave $1 $3) }
    | Exp "[|" Exp "|]" Exp         { AN2 (GenParallel $1 $3 $5) }
    | Exp "[" Exp "||" Exp "]" Exp  { AN2 (AlphaParallel $1 $3 $5 $7) }
    | Exp "/\\" Exp                 { AN2 (Interrupt $1 $3) }
    | Exp "[|" Exp "|>" Exp         { AN2 (Exception $1 $3 $5) }
    | Exp "[>" Exp                  { AN2 (SlidingChoice $1 $3) }
    | Exp ";" Exp                   { AN2 (SequentialComp $1 $3) }
    | Exp "&" Exp                   { AN2 (GuardedExp $1 $3) }

    | Exp "[+" Exp "+]" Exp         { AN2 (SynchronisingExternalChoice $1 $3 $5) }
    | Exp "/+" Exp "+\\" Exp        { AN2 (SynchronisingInterrupt $1 $3 $5) }

    --- TODO: check all on LHS are generators only
    -- TODO: check LHS all use <- only
    | Exp "[[" RenameList1 OptStmtList "]]" { AN2 (Rename $1 $3 $4) }
    | Exp "[" TieList1 OptStmtList "]" Exp  { AN2 (LinkParallel $1 $3 $4 $6) }

    | "|||" StmtCommaList "@" Exp   { AN2 (ReplicatedInterleave $2 $4) }
    | "[]" StmtCommaList "@" Exp    { AN2 (ReplicatedExternalChoice $2 $4) }
    | "|~|" StmtCommaList "@" Exp   { AN2 (ReplicatedInternalChoice $2 $4) }
    | "||" StmtCommaList "@" "[" Exp "]" Exp { AN2 (ReplicatedAlphaParallel $2 $5 $7) }
    | "[|" Exp "|]" StmtCommaList "@" Exp { AN2 (ReplicatedParallel $2 $4 $6) }
    | "[" TieList1 OptStmtList "]" StmtCommaList "@" Exp { AN2 (ReplicatedLinkParallel $2 $3 $5 $7) }
    | ";" StmtCommaList "@" Exp     { AN2 (ReplicatedSequentialComp $2 $4) }
    | "[+" Exp "+]" StmtCommaList "@" Exp
                                    { AN2 (ReplicatedSynchronisingExternalChoice
                                        $2 $4 $6) }

Field :: { PField }
    :
    -- For somer reason changing Exp to Pat causes a shift/reduce error, hence we do this
    "?" Exp                         { AN2 (Input (convPat $2) Nothing) }
    | "?" Exp ":" Exp               { AN2 (Input (convPat $2) (Just (checkExp $4))) }
    | "$" Exp                       { AN2 (NonDetInput (convPat $2) Nothing) }
    | "$" Exp ":" Exp               { AN2 (NonDetInput (convPat $2) (Just (checkExp $4))) }
    | "!" Exp                       { AN2 (Output (checkExp $2)) }

Rename :: { (PExp, PExp) }
    :
    CExp "<-" CExp                  { ($1, $3) }
RenameList1 :: { [(PExp, PExp)] }
    :
    rRenameList1                    { reverse $1 }
rRenameList1 :: { [(PExp, PExp)] }
    :
    Rename                          { [$1] }
    | rRenameList1 "," Rename       { $3:$1 }
Tie :: { (PExp, PExp) }
    :
    CExp "<->" CExp                 { ($1, $3) }
TieList1 :: { [(PExp, PExp)] }
    :
    rTieList1                       { reverse $1 }
rTieList1 :: { [(PExp, PExp)] }
    :
    Tie                             { [$1] }
    | rTieList1 "," Tie             { $3:$1 }

FieldList :: { [PField] }
    :
     rFieldList                     { reverse $1 }
rFieldList :: { [PField] }
    :
    Field                           { [$1] }
    | rFieldList Field              { $2:$1 }

-- List containing at least 2 items
ExpCommaList2 :: { [PExp] }
    :
    Exp "," rExpCommaList       { $1:(reverse $3) }
-- List containing at least 1 items
ExpCommaList1 :: { [PExp] }
    :
    rExpCommaList                   { reverse $1 }
ExpCommaList :: { [PExp] }
    :
                                    { [] }
    | rExpCommaList                 { reverse $1 }
rExpCommaList :: { [PExp] }
    :
    rExpCommaList "," Exp           { $3:$1 }
    | Exp                           { [$1] }

ExpMapCommaList :: { [(PExp, PExp)] }
    :
                                    { [] }
    | rExpMapCommaList              { reverse $1 }
rExpMapCommaList :: { [(PExp, PExp)] }
    :
    rExpMapCommaList "," Exp "=>" Exp   { ($3, $5):$1 }
    | Exp "=>" Exp                      { [($1, $3)] }

-- ****************************************
-- Statements
OptStmtList :: { [PStmt] }
    :
                                    { [] }
    | "|" StmtCommaList             { $2 }
Stmt :: { PStmt }
    :
    Pat "<-" Exp                    { AN2 (Generator $1 $3) }
    | Pat ":" Exp                   { AN2 (Generator $1 $3) }
    | Exp                           { AN (Qualifier $1) }
StmtCommaList :: { [PStmt] }
    :
    rStmtCommaList                  { reverse $1 }
rStmtCommaList :: { [PStmt] }
    :
    rStmtCommaList "," Stmt         { $3:$1 }
    | Stmt                          { [$1] }

{
combineDecls :: [PDecl] -> [PDecl]
combineDecls [] = []
combineDecls ((An loc1 b (FunBind n ms Nothing)):
            (An loc2 c (FunBind n1 ms1 Nothing)):ds)
        | n == n1 && srcSpanFile loc1 == srcSpanFile loc2 =
    combineDecls $
        (An (combineSpans loc1 loc2) b (FunBind n (ms++ms1) Nothing)):ds
combineDecls (d:ds) = d:combineDecls ds

constraintForName :: SrcSpan -> String -> Constraint
constraintForName _ "Eq" = CEq
constraintForName _ "Ord" = COrd
constraintForName _ "Inputable" = CInputable
constraintForName _ "Set" = CSet
constraintForName _ "Yieldable" = CYieldable
constraintForName loc s = throwSourceError [unknownConstraintError s loc]

attachTypeAnnotations :: [PDecl] -> [PDecl]
attachTypeAnnotations ds =
    let
        extractTypeAnnotations :: Decl UnRenamedName ->
            [(UnRenamedName, PSTypeScheme)]
        extractTypeAnnotations (ParsedTypeAnnotation ns ta) =
            [(n, ta) | n <- ns]
        extractTypeAnnotations _ = []

        extractedAnnotations =
            concatMap (extractTypeAnnotations . unAnnotate) ds

        nameLocs :: [(UnRenamedName, SrcSpan)]
        nameLocs = [(n, loc x) | (n, x) <- extractedAnnotations]

        locsByName :: [(UnRenamedName, [SrcSpan])]
        locsByName =
            map (\ nss -> (fst (head nss), map snd nss)) $
            groupBy (\x y -> fst x == fst y) $
            sortBy (\ x y -> compare (fst x) (fst y)) nameLocs

        dupeErrors = concatMap (\ (n, locs) ->
            case locs of
                [_] -> []
                _ -> [ambiguousTypeAnnotationsError n locs]
            ) locsByName

        nameForDecl  (An _ _ (FunBind n _ _)) = [n]
        nameForDecl (An _ _ (PatBind (An _ _ (PVar n)) _ _)) = [n]
        nameForDecl _ = []

        allNames = nub $ sort $ map fst nameLocs
        usedNames = nub $ sort $ concatMap nameForDecl ds
        unusedNames = allNames \\ usedNames
        unusedErrors = map (\ n ->
                case lookup n nameLocs of
                    Just loc -> unusedTypeAnnotationsError n loc
                    _ -> panic "attachTypeAnnotations: logic error"
            ) unusedNames

        typeAnMap = M.fromList extractedAnnotations
            
        annotationForName n =
            M.findWithDefault (panic "attachedTypeAnnotations: invalid state")
                n typeAnMap

        annotateDecl :: PDecl -> [PDecl]
        annotateDecl (An x y (FunBind n ms Nothing)) | M.member n typeAnMap =
            [An x y (FunBind n ms (Just $ annotationForName n))]
        annotateDecl (An x y (PatBind (p@(An _ _ (PVar n))) e Nothing))
                | M.member n typeAnMap =
            [An x y (PatBind p e (Just $ annotationForName n))]
        annotateDecl (An _ _ (ParsedTypeAnnotation _ _)) = []
        annotateDecl d = [d]
    in if length dupeErrors > 0 then
            throwSourceError dupeErrors
        else if length unusedErrors > 0 then
            throwSourceError unusedErrors
        else concatMap annotateDecl ds

convDecl :: PExp -> PExp -> ParseMonad PDecl
convDecl lhs rhs | srcSpanFile (loc lhs) /= srcSpanFile (loc rhs) =
    throwSourceError [definitionSpanFileError lhs rhs (loc lhs)]
convDecl (lhs @ (An loc1 b lhsexp)) (rhs @ (An loc2 d _)) = 
    let
        span = combineSpans loc1 loc2

        -- REMEMBER: needs to reverse pts
        getPats :: Exp UnRenamedName -> ([[PPat]], UnRenamedName)
        getPats (App f args) = 
                ((map convPat args):ps, n)
            where
                (ps, n) = getPats (unAnnotate f)
        getPats (Var n) = ([], n)
        
        convFunBind exp = 
                FunBind n [An span (dummyAnnotation) (Match (reverse ps) rhs)]
                    Nothing
            where
                (ps, n) = getPats exp

        convPatBind exp = PatBind (convPat exp) rhs Nothing
    in do
        symbTable <- freshPSymbolTable
        case lhsexp of
            App f args  -> return $ An span (Nothing, symbTable) (convFunBind lhsexp)
            _           -> return $ An span (Nothing, symbTable) (convPatBind lhs)

-- | Throws an error if a declaration that is not allowed inside a let 
-- expression is found.
checkLetDecls :: [PDecl] -> [PDecl]
checkLetDecls decls =
    if and (map checkDecl decls) then
        decls
    else panic "checkLetDecls: Invalid state."
    where
        checkDecl :: PDecl -> Bool
        checkDecl (anDecl@(An _ _ decl)) =
            let
                check (FunBind _ _ _) = True
                check (PatBind _ _ _) = True
                check (External a) = True
                check (Transparent a) = True
                check (TimedSection _ _ ds) = and (map checkDecl ds)
                -- We cant allow module instances as this would cause channels
                -- to be declared in let statements, which would lead to Events
                -- being hard to define
                -- check (ModuleInstance _ _ _ _ _) = True
                check _ = throwSourceError [invalidLetDeclarationErrorMessage anDecl]
            in check decl
    
checkModuleDecl :: PDecl -> PDecl
checkModuleDecl (anDecl@(An _ _ (Assert _))) =
    throwSourceError [invalidModuleDeclarationErrorMessage anDecl]
checkModuleDecl (anDecl@(An _ _ (PrintStatement _))) =
    throwSourceError [invalidModuleDeclarationErrorMessage anDecl]
checkModuleDecl (anDecl@(An x y (TimedSection a b ds))) =
    An x y (TimedSection a b (map checkModuleDecl ds))
checkModuleDecl d = d

checkTimedDecl :: PDecl -> PDecl
checkTimedDecl (anDecl@(An _ _ (PrintStatement _))) =
    throwSourceError [invalidTimedSectionDeclarationErrorMessage anDecl]
checkTimedDecl d = d

checkExp :: PExp -> PExp
-- Transform X \ Y ||| Z (which will have been parsed as X \ (Y ||| Z)) into
-- (X \ Y) ||| Z (and ditto for other parallel operators). Note that we cannot
-- do this using precedences, since we do want X ||| Y \ Z to bracket \ Z around
-- the whole of X ||| Y. Thus, we really need a context dependent precedence,
-- which happy doesnt have.
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (Interleave e2 e3)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (Interleave (An lhide an2 (Hiding e1a e2a)) e3a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (GenParallel e2 e3 e4)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        e4a = checkExp e4
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (GenParallel (An lhide an2 (Hiding e1a e2a)) e3a e4a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (AlphaParallel e2 e3 e4 e5)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        e4a = checkExp e4
        e5a = checkExp e5
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (AlphaParallel (An lhide an2 (Hiding e1a e2a)) e3a e4a e5a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (Exception e2 e3 e4)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        e4a = checkExp e4
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (Exception (An lhide an2 (Hiding e1a e2a)) e3a e4a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (InternalChoice e2 e3)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (InternalChoice (An lhide an2 (Hiding e1a e2a)) e3a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (ExternalChoice e2 e3)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (ExternalChoice (An lhide an2 (Hiding e1a e2a)) e3a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (Interrupt e2 e3)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (Interrupt (An lhide an2 (Hiding e1a e2a)) e3a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (SlidingChoice e2 e3)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (SlidingChoice (An lhide an2 (Hiding e1a e2a)) e3a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (SequentialComp e2 e3)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (SequentialComp (An lhide an2 (Hiding e1a e2a)) e3a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (SynchronisingExternalChoice e2 e3 e4)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        e4a = checkExp e4
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (SynchronisingExternalChoice (An lhide an2 (Hiding e1a e2a)) e3a e4a)
checkExp (An l1 an1 (Hiding e1 (An l2 an2 (SynchronisingInterrupt e2 e3 e4)))) =
    let
        e1a = checkExp e1
        e2a = checkExp e2
        e3a = checkExp e3
        e4a = checkExp e4
        -- The parallel location is simply the whole expression
        lpar = l1
        lhide = combineSpans (loc e1a) (loc e2a)
    in An lpar an1 (SynchronisingInterrupt (An lhide an2 (Hiding e1a e2a)) e3a e4a)
checkExp (anExp@(An a b exp)) =
    let 
        check :: Exp UnRenamedName -> Exp UnRenamedName
        check (App e es) = App (checkExp e) (map checkExp es)
        check (BooleanBinaryOp op e1 e2) = BooleanBinaryOp op (checkExp e1) (checkExp e2)
        check (BooleanUnaryOp op e) = BooleanUnaryOp op (checkExp e)
        check (Concat e1 e2) = Concat (checkExp e1) (checkExp e2)
        check (DotApp e1 e2) = DotApp (checkExp e1) (checkExp e2)
        check (If e1 e2 e3) = If (checkExp e1) (checkExp e2) (checkExp e3)
        check (Lambda p e) = Lambda p (checkExp e)
        check (Let decls e) = Let decls (checkExp e)
        check (Lit lit) = Lit lit
        check (List es) = List (map checkExp es)
        check (ListComp es stmts) = ListComp (map checkExp es) stmts
        check (ListEnumFrom e) = ListEnumFrom (checkExp e)
        check (ListEnumFromTo e1 e2) = ListEnumFromTo (checkExp e1) (checkExp e2)
        check (ListEnumFromComp e1 stmts) = ListEnumFromComp (checkExp e1) stmts
        check (ListEnumFromToComp e1 e2 stmts) =
            ListEnumFromToComp (checkExp e1) (checkExp e2) stmts
        check (ListLength e) = ListLength (checkExp e)
        check (Map kvs) = Map (map (\ (k, v) -> (checkExp k, checkExp v)) kvs)
        check (MathsBinaryOp op e1 e2) = MathsBinaryOp op (checkExp e1) (checkExp e2)
        check (MathsUnaryOp op e) = MathsUnaryOp op (checkExp e)
        check (Paren e) = Paren (checkExp e)
        check (Set es) = Set (map checkExp es)
        check (SetComp es stmts) = SetComp (map checkExp es) stmts
        check (SetEnumFrom e) = SetEnumFrom (checkExp e)
        check (SetEnumFromTo e1 e2) = SetEnumFromTo (checkExp e1) (checkExp e2)
        check (SetEnumFromComp e1 stmts) = SetEnumFromComp (checkExp e1) stmts
        check (SetEnumFromToComp e1 e2 stmts) =
            SetEnumFromToComp (checkExp e1) (checkExp e2) stmts
        check (SetEnum es) = SetEnum (map checkExp es)
        -- We dont need to check inside stmts as they will have been checked
        -- upon creation
        check (SetEnumComp es stmts) = SetEnumComp (map checkExp es) stmts
        check (Tuple es) = Tuple (map checkExp es)
        check (Var qname) = Var qname

        check (AlphaParallel e1 e2 e3 e4) = 
            AlphaParallel (checkExp e1) (checkExp e2) (checkExp e3) (checkExp e4)
        check (Exception e1 e2 e3) = Exception (checkExp e1) (checkExp e2) (checkExp e3)
        check (ExternalChoice e1 e2) = ExternalChoice (checkExp e1) (checkExp e2)
        check (GenParallel e1 e2 e3) = GenParallel (checkExp e1) (checkExp e2) (checkExp e3)
        check (GuardedExp e1 e2) = GuardedExp (checkExp e1) (checkExp e2)
        check (Hiding e1 e2) = Hiding (checkExp e1) (checkExp e2)
        check (InternalChoice e1 e2) = InternalChoice (checkExp e1) (checkExp e2)
        check (Interrupt e1 e2) = Interrupt (checkExp e1) (checkExp e2)
        check (Interleave e1 e2) = Interleave (checkExp e1) (checkExp e2)
        check (LinkParallel e1 ties stmts e2) = 
            LinkParallel (checkExp e1) ties stmts (checkExp e2)
        check (Prefix e1 fields e2) = Prefix (checkExp e1) fields (checkExp e2)
        check (Rename e ties stmts) = Rename (checkExp e) ties stmts
        check (SequentialComp e1 e2) = SequentialComp (checkExp e1) (checkExp e2)
        check (SlidingChoice e1 e2) = SlidingChoice (checkExp e1) (checkExp e2)
        check (SynchronisingExternalChoice e1 e2 e3) =
            SynchronisingExternalChoice (checkExp e1) (checkExp e2) (checkExp e3)
        check (SynchronisingInterrupt e1 e2 e3) =
            SynchronisingInterrupt (checkExp e1) (checkExp e2) (checkExp e3)

        check (ReplicatedAlphaParallel stmts e1 e2) = 
            ReplicatedAlphaParallel stmts (checkExp e1) (checkExp e2)
        check (ReplicatedInterleave stmts e1) = ReplicatedInterleave stmts (checkExp e1)
        check (ReplicatedExternalChoice stmts e1) = ReplicatedExternalChoice stmts (checkExp e1)
        check (ReplicatedInternalChoice stmts e1) = ReplicatedInternalChoice stmts (checkExp e1)
        check (ReplicatedParallel e1 stmts e2) = 
            ReplicatedParallel (checkExp e1) stmts (checkExp e2)
        check (ReplicatedLinkParallel ties tiesStmts stmts e) = 
            ReplicatedLinkParallel ties tiesStmts stmts (checkExp e)
        check (ReplicatedSequentialComp stmts e1) = 
            ReplicatedSequentialComp stmts (checkExp e1)
        check (ReplicatedSynchronisingExternalChoice e1 stmts e3) =
            ReplicatedSynchronisingExternalChoice (checkExp e1) stmts
                (checkExp e3)
        
        check x = throwSourceError [invalidExpressionErrorMessage anExp]
    in
        An a b (check exp)

getFuncArgs :: PSType -> [PSType]
getFuncArgs (An _ _ (STParen s)) = [s]
getFuncArgs (An _ _ (STTuple ts)) = ts
getFuncArgs s = throwSourceError [invalidFunctionArgsErrorMessage s]

dotAppToList :: PExp -> [PExp]
dotAppToList (An a b exp) = 
    let 
        list :: Exp UnRenamedName -> [PExp]
        list (DotApp e1 e2) = (dotAppToList e1) ++ (dotAppToList e2)
        list x = [An a b x]
    in
        list exp

convPat :: PExp -> PPat
convPat (anExp@ (An a b exp)) = 
    let
        trans :: Exp UnRenamedName -> Pat UnRenamedName
        trans (Concat e1 e2) = PConcat (convPat e1) (convPat e2)
        trans (DotApp e1 e2) = PDotApp (convPat e1) (convPat e2)
        trans (List xs) = PList (map convPat xs)
        trans (Lit x) = PLit x
        trans (MathsUnaryOp Negate e) =
            case trans (unAnnotate e) of
                PLit (Int x) -> PLit (Int (-x))
                _ -> throwSourceError [invalidPatternErrorMessage anExp]
        trans (Set xs) = PSet (map convPat xs)
        trans (Paren x) = PParen (convPat x)
        trans (Tuple xs) = PTuple (map convPat xs)
        trans (Var x) = PVar x
        trans (ExpPatWildCard) = PWildCard
        trans (ExpPatDoublePattern e1 e2) = 
            PDoublePattern (convPat e1) (convPat e2)
        trans x = throwSourceError [invalidPatternErrorMessage anExp]
    in
        An a b (trans exp)

stripParen :: PExp -> PExp
stripParen (An _ _ (Paren e)) = stripParen e
stripParen e = e

makeDotApp :: PExp -> PExp -> PExp
makeDotApp e1 e3 =
    case stripParen e1 of
        An _ typ (DotApp e1 e2) -> annotate2 e1 right $ DotApp e1 right
            where
                An loc _ rightP = annotate2 e2 e3 $ DotApp e2 e3
                right = An loc typ rightP
        _ -> annotate2 e1 e3 (DotApp e1 e3)

makeSTDot :: PSType -> PSType -> PSType
makeSTDot (An loc typ (STDot e1 e2)) e3 = annotate2 e1 right $ STDot e1 right
    where right = annotate2 e2 e3 $ STDot e2 e3
makeSTDot e1 e2 = annotate2 e1 e2 (STDot e1 e2)

-- Helper function to get the contents of tokens
getInt (L _ (TInteger x)) = x
getChar (L _ (TChar c)) = c
getString (L _ (TString s)) = s
getName (L _ (TIdent x)) = x
getRefinesModel (L _ (TRefines x)) = x
getPropModel (L _ (TModel x)) = x
getPrintString (L _ (TPrint x)) = x

class Locatable a where
    getLoc :: a b -> SrcSpan
    unLoc :: a b -> b
    mkLoc :: SrcSpan -> b -> a b

instance Locatable Located where
    getLoc (L loc _) = loc
    unLoc (L _ b) = b
    mkLoc loc b = L loc b

instance Locatable (Annotated a) where
    getLoc (An loc _ _) = loc
    unLoc (An _ _ b) = b
    mkLoc loc b = An loc dummyAnnotation b

annotate :: (Locatable t1, Locatable t2) => t1 a -> b -> t2 b
annotate t1 b = mkLoc (getLoc t1) b

annotate2 :: 
    (Locatable t1, Locatable t2, Locatable t3) => t1 a -> t2 b -> c -> t3 c
annotate2 t1 t2 b = mkLoc (combineSpans (getLoc t1) (getLoc t2)) b
annotate2List :: 
    (Locatable t1, Locatable t2, Locatable t3) => t1 a -> [t2 b] -> c -> t3 c
annotate2List t1 t2 b = annotate2 t1 (last t2) b
annotate2Lista :: 
    (Locatable t1, Locatable t2, Locatable t3) => [t1 a] -> t2 b -> c -> t3 c
annotate2Lista t1 t2 b = annotate2 (last t1) t2 b

annotateWithSymbolTable 
    :: Annotated (Maybe SymbolTable, PSymbolTable) a -> ParseMonad (Annotated (Maybe SymbolTable, PSymbolTable) a)
annotateWithSymbolTable (An l _ a) = do
    symbTable <- freshPSymbolTable
    return $ An l (Nothing, symbTable) a

liftLoc :: (Locatable t1, Locatable t2) => t1 a -> b -> t2 b
liftLoc t1 b = mkLoc (getLoc t1) b

parseError :: LToken -> ParseMonad a
parseError tok = throwSourceError [parseErrorMessage tok]
}
